import { getData, setData, dataStoreType, user, channel, message, dm } from './dataStore';
import { channelsListV2 } from './channels';
import { dmListV2 } from './dm';
import HTTPError from 'http-errors';

type channelOutput = {
  channelId: number;
  name: string;
}

type dmOutput = {
  dmId: number;
  name: string;
}

const REMOVE = 'r';
const EDIT = 'e';

const FORBID = 403;
const BAD_REQ = 400;

/**
 * Given a valid inputs, sends message from user to specified channel and
 * returns a unique message id.
 *
 * Arguments:
 *      token:      string     The user's unique identifier
 *      channelId:  number     The channel's unique identifier
 *      message:    string     The message
 *
 * Returns:
 *      { messageId: <number> } object     Successful message send
 */
export function messageSendV2(token: string, channelId: number, message: string) {
  const data: dataStoreType = getData();

  // Token validation
  if (data.users.find(user => user.tokens.find(tok => tok === token)) === undefined) {
    throw HTTPError(FORBID, 'Invalid token');
  }

  const userId: number = data.users.find(user => user.tokens.find(tok => tok === token)).uId;
  const channelsMemberOf: Array<channelOutput> = channelsListV2(token).channels;

  // Checking if valid channelIds were given
  // Validating if authorised user is a member of the channel
  if (data.channels.find(channel => channel.channelId === channelId) === undefined) {
    throw HTTPError(BAD_REQ, 'Invalid channelId');
  } else if (channelsMemberOf.find(channel => channel.channelId === channelId) === undefined) {
    throw HTTPError(FORBID, 'Not a member of channel');
  }

  const channelGivenIndex: number = data.channels.findIndex(channel => channel.channelId === channelId);

  // Message validation
  if (message.length < 1 || message.length > 1000) {
    throw HTTPError(BAD_REQ, 'Invalid message length');
  }

  const newMessageId = sendMessage('c', userId, message, channelGivenIndex);
  return { messageId: newMessageId };
}

/**
 * Given a valid inputs, sends message from user to specified dm and
 * returns a unique message id.
 *
 * Arguments:
 *      token:      string     The user's unique identifier
 *      dmId:       number     The channel's unique identifier
 *      message:    string     The edited message
 *
 * Returns:
 *      { error: 'error' }      object     Error message (given invalid input)
 *      { messageId: <number> } object     Successful message send
 */
export function messageSendDmV2(token: string, dmId: number, message: string) {
  const data: dataStoreType = getData();

  // Token validation
  if (data.users.find(user => user.tokens.find(tok => tok === token)) === undefined) {
    throw HTTPError(FORBID, 'Invalid token');
  }

  const userId: number = data.users.find(user => user.tokens.find(tok => tok === token)).uId;
  const dmsMemberOf: Array<dmOutput> = dmListV2(token).dms;

  // Checking if valid dmId was given
  // Validating if authorised user is a member of the DM
  if (data.dms.find(dm => dm.dmId === dmId) === undefined) {
    throw HTTPError(BAD_REQ, 'Invalid dmId');
  } else if (dmsMemberOf.find(dm => dm.dmId === dmId) === undefined) {
    throw HTTPError(FORBID, 'Not a member of dm');
  }

  const dmGivenIndex: number = data.dms.findIndex(dm => dm.dmId === dmId);

  // Message validation
  if (message.length < 1 || message.length > 1000) {
    throw HTTPError(BAD_REQ, 'Invalid message length');
  }

  const newMessageId = sendMessage('d', userId, message, dmGivenIndex);
  return { messageId: newMessageId };
}

/**
 * Given a valid mode (c/d), an id is generated by appending mode,
 * Unix timestamp and random number.
 *
 * Arguments:
 *      mode:      string     'c' denotes channel
 *                            'd' denotes dm
 *
 * Returns:
 *      newId      number     A unique identifier
 */
function generateId(mode: string) {
  let newId: string;
  if (mode === 'c') {
    newId = '1' + String(Date.now()) + String(Math.floor(Math.random() * 100));
  } else if (mode === 'd') {
    newId = '2' + String(Date.now()) + String(Math.floor(Math.random() * 100));
  }

  return Number(newId);
}

/**
* Given a valid messageId and message, the message with messageId is found
* and replaced with new message.
*
* Arguments:
*      token:      string     The user's unique identifier
*      messageId:  number     The messages's unique identifier
*      message:    string     The edited message
*
* Returns:
*      { }                    object     Successful messageEdit
*/
export function messageEditV2(token: string, messageId: number, message: string) {
  const data: dataStoreType = getData();
  const mode = EDIT;

  // Token validation
  if (data.users.find(user => user.tokens.find(tok => tok === token)) === undefined) {
    throw HTTPError(FORBID, 'Invalid token');
  }

  // Get user information
  const user: user = data.users.find(user => user.tokens.find(tok => tok === token));
  const userId = user.uId;
  let isGlobalUser: boolean;
  if (user.isGlobalOwner === 1) {
    isGlobalUser = true;
  } else {
    isGlobalUser = false;
  }

  // Message validation
  if (message.length > 1000) {
    throw HTTPError(BAD_REQ, 'Invalid message length');
  } else if (message.length === 0) {
    return messageRemoveV2(token, messageId);
  }

  const firstDigit = String(messageId)[0];
  if (firstDigit === '1') {
    return editInChannel(mode, token, userId, isGlobalUser, messageId, message);
  } else if (firstDigit === '2') {
    return editInDm(mode, token, userId, messageId, message);
  }
}

/**
 * Given a valid messageId, the message is removed from the channel or dm
 *
 * Arguments:
 *      token:      string     The user's unique identifier
 *      messageId:  number     The message's unique identifier
 *
 * Returns:
 *      { error: 'error' }      object     Error message (given invalid input)
 *      { }                     object     Successful message remove
 */
export function messageRemoveV2(token: string, messageId: number) {
  const data: dataStoreType = getData();
  const mode = REMOVE;

  // Token validation
  if (data.users.find(user => user.tokens.find(tok => tok === token)) === undefined) {
    throw HTTPError(FORBID, 'Invalid token');
  }

  // Get user information
  const user: user = data.users.find(user => user.tokens.find(tok => tok === token));
  const userId = user.uId;
  let isGlobalUser: boolean;
  if (user.isGlobalOwner === 1) {
    isGlobalUser = true;
  } else {
    isGlobalUser = false;
  }

  const firstDigit = String(messageId)[0];
  if (firstDigit === '1') {
    return editInChannel(mode, token, userId, isGlobalUser, messageId);
  } else if (firstDigit === '2') {
    return editInDm(mode, token, userId, messageId);
  }
}

/**
 * Helper function for messageEditV1/messageRemoveV1 to edit/ remove messages in channels.
 *
 * Arguments:
 *      token:          string     The user's unique identifier
 *      userId:         number     The user's identifier
 *      isGlobalUser:   boolean    The user's global permissions
 *      messageId:      number     The message's unique identifier
 *      message:        string     The edited message
 *
 * Returns:
 *      { error: 'error' }     object     Error message when given invalid input
 *      { }                    object     Successful messageEdit
 */
function editInChannel(mode: string, token: string, userId: number, isGlobalUser: boolean, messageId: number, message?: string) {
  const data: dataStoreType = getData();

  const channelGiven: channel = isMessageValidChannel(messageId);

  let isMember: boolean;
  const channelsMemberOf: Array<channelOutput> = channelsListV2(token).channels;
  if (channelsMemberOf.find(channel => channel.channelId === channelGiven.channelId) === undefined) {
    isMember = false;
  } else {
    isMember = true;
  }

  const messageGiven: message = channelGiven.messages.find(message => message.messageId === messageId);

  // Checks if user is global owner (who can edit messages), otherwise check further:
  if (isGlobalUser === false) {
    // Checks if user is not owner of channel (who can edit messages), otherwise check further:
    if (channelGiven.ownerMembers.find(owner => owner === userId) === undefined) {
      // Checks if user is part of the channel (i.e. did not leave channel)
      if (isMember === false) {
        throw HTTPError(BAD_REQ, 'Invalid user accessing valid message');
        // Checks if the user (who is a member of channel) is the one wrote message
      } else if (messageGiven.uId !== userId) {
        throw HTTPError(FORBID, 'Invalid user accessing message');
      }
    }
  }

  const messageGivenIndex: number = channelGiven.messages.findIndex(message => message.messageId === messageId);
  const channelGivenIndex: number = data.channels.findIndex(channel => channel.channelId === channelGiven.channelId);

  if (mode === EDIT) {
    data.channels[channelGivenIndex].messages[messageGivenIndex].message = message;
  } else if (mode === REMOVE) {
    const removedMessage: Array<message> = channelGiven.messages.filter(message => message.messageId !== messageId);
    data.channels[channelGivenIndex].messages = removedMessage;
  }

  setData(data);
  return {};
}

/**
 * Helper function for messageEditV1/messageRemoveV1 to edit/remove messages in dms.
 *
 * Arguments:
 *      token:          string     The user's unique identifier
 *      userId:         number     The user's identifier
 *      messageId:      number     The message's unique identifier
 *      message:        string     The edited message
 *
 * Returns:
 *      { error: 'error' }     object     Error message when given invalid input
 *      { }                    object     Successful messageEdit
 */
function editInDm(mode: string, token: string, userId: number, messageId: number, message?: string) {
  const data: dataStoreType = getData();

  const dmGiven: dm = isMessageValidDm(messageId);

  let isMember: boolean;
  const dmsMemberOf: Array<dmOutput> = dmListV2(token).dms;
  if (dmsMemberOf.find(dm => dm.dmId === dmGiven.dmId) === undefined) {
    isMember = false;
  } else {
    isMember = true;
  }

  const messageGiven: message = dmGiven.messages.find(message => message.messageId === messageId);

  // If user is not owner of channel: If user is not the person who wrote it then return error
  if (dmGiven.owner !== userId) {
    if (isMember === false) {
      throw HTTPError(BAD_REQ, 'Invalid user accessing valid message');
    } else if (messageGiven.uId !== userId) {
      throw HTTPError(FORBID, 'Invalid user accessing message');
    }
  }

  const messageGivenIndex: number = dmGiven.messages.findIndex(message => message.messageId === messageId);
  const dmGivenIndex: number = data.dms.findIndex(dm => dm.dmId === dmGiven.dmId);

  if (mode === EDIT) {
    data.dms[dmGivenIndex].messages[messageGivenIndex].message = message;
  } else if (mode === REMOVE) {
    const removedMessage: Array<message> = dmGiven.messages.filter(message => message.messageId !== messageId);
    data.dms[dmGivenIndex].messages = removedMessage;
  }

  setData(data);
  return {};
}

/**
 * Given a valid ogMessageId, an optional message is attached and sent to the
 * specified channel or dm, and returns the a messageId.
 *
 * Arguments:
 *      token:              string     The user's unique identifier
 *      ogMessageId:        number     The message's unique identifier
 *      message:            string     The message
 *      channelId:          number     The channel's unique identifier or -1
 *      dmId:               number     The dm's unique identifier or -1
 *
 * Returns:
 *      sharedMessageId:    number     The message's unique identifier
 */
export function messageShareV1(token: string, ogMessageId: number, message: string, channelId: number, dmId: number) {
  const data: dataStoreType = getData();

  // Token validation
  if (data.users.find(user => user.tokens.find(tok => tok === token)) === undefined) {
    throw HTTPError(FORBID, 'Invalid token');
  }

  const user: user = data.users.find(user => user.tokens.find(tok => tok === token));
  const userId = user.uId;

  // Checking valid id pairs given
  if (channelId > 0 && dmId !== -1) {
    throw HTTPError(BAD_REQ, 'Invalid id pair');
  } else if (dmId > 0 && channelId !== -1) {
    throw HTTPError(BAD_REQ, 'Invalid id pair');
  }

  // Checking validity of message length
  if (message.length > 1000) {
    throw HTTPError(BAD_REQ, 'Invalid message length');
  }

  const channelsMemberOf: Array<channelOutput> = channelsListV2(token).channels;
  const dmsMemberOf: Array<dmOutput> = dmListV2(token).dms;

  // Checking if ogMessageId is valid and if user is part of the channel/dm
  let ogChannel: channel;
  let ogDm: dm;
  let ogMessage: message;
  const firstDigit = String(ogMessageId)[0];
  if (firstDigit === '1') {
    ogChannel = isMessageValidChannel(ogMessageId);

    if (channelsMemberOf.find(channel => channel.channelId === ogChannel.channelId) === undefined) {
      throw HTTPError(BAD_REQ, 'Invalid access to ogChannel');
    }

    ogMessage = ogChannel.messages.find(message => message.messageId === ogMessageId);
  } else if (firstDigit === '2') {
    ogDm = isMessageValidDm(ogMessageId);

    if (dmsMemberOf.find(dm => dm.dmId === ogDm.dmId) === undefined) {
      throw HTTPError(BAD_REQ, 'Invalid access to ogDm');
    }

    ogMessage = ogDm.messages.find(message => message.messageId === ogMessageId);
  }

  // Checking validity of channelId or dmId
  let sharedMessageId;
  if (dmId === -1) {
    const channelGivenIndex = data.channels.findIndex(channel => channel.channelId === channelId);
    if (channelGivenIndex === -1) {
      throw HTTPError(BAD_REQ, 'Invalid channelId');
    }

    if (channelsMemberOf.find(channel => channel.channelId === channelId) === undefined) {
      throw HTTPError(FORBID, 'Invalid access to channel');
    }

    sharedMessageId = sendMessage('c', userId, message, channelGivenIndex, ogMessage.message);
    return { sharedMessageId: sharedMessageId };
  } else if (channelId === -1) {
    const dmGivenIndex = data.dms.findIndex(dm => dm.dmId === dmId);
    if (dmGivenIndex === -1) {
      throw HTTPError(BAD_REQ, 'Invalid dmId');
    }

    if (dmsMemberOf.find(dm => dm.dmId === dmId) === undefined) {
      throw HTTPError(FORBID, 'Invalid access to dm');
    }

    sharedMessageId = sendMessage('d', userId, message, dmGivenIndex, ogMessage.message);
    return { sharedMessageId: sharedMessageId };
  }
}

export function messageSendLaterV1(token: string, channelId: number, message: string, timeSent: number) {
  const timeRemain: number = Math.ceil(timeSent - Math.floor(Date.now() / 1000)) * 1000;
  if (timeRemain < 0) {
    throw HTTPError(BAD_REQ, 'Invalid time');
  }

  sleep(timeRemain);
  return messageSendV2(token, channelId, message);
}

export function messageSendLaterDmV1(token: string, dmId: number, message: string, timeSent: number) {
  const timeRemain: number = Math.ceil(timeSent - Math.floor(Date.now() / 1000)) * 1000;
  if (timeRemain < 0) {
    throw HTTPError(BAD_REQ, 'Invalid time');
  }

  sleep(timeRemain);
  return messageSendDmV2(token, dmId, message);
}

function sleep(timeRemain: number) {
  Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, timeRemain);
}

/**
 * Given a valid messageId, the message is marked as pinned.
 *
 * Arguments:
 *      token:      string     The user's unique identifier
 *      messageId:  number     The message's unique identifier
 *
 * Returns:
 *      { }         object     Successful message pin
 */
export function messagePinV1(token: string, messageId: number) {
  return pinMessage('p', token, messageId);
}

/**
 * Given a valid messageId, the message is marked as pinned.
 *
 * Arguments:
 *      token:      string     The user's unique identifier
 *      messageId:  number     The message's unique identifier
 *
 * Returns:
 *      { }         object     Successful message unpin
 */
export function messageUnPinV1(token: string, messageId: number) {
  return pinMessage('u', token, messageId);
}

function pinMessage(mode: string, token: string, messageId: number) {
  const data: dataStoreType = getData();

  // Token validation
  if (data.users.find(user => user.tokens.find(tok => tok === token)) === undefined) {
    throw HTTPError(FORBID, 'Invalid token');
  }

  // Finding userId
  const user: user = data.users.find(user => user.tokens.find(tok => tok === token));
  const userId: number = user.uId;

  // Finding the channels and dms the user is a member of
  const channelsMemberOf: Array<channelOutput> = channelsListV2(token).channels;
  const dmsMemberOf: Array<dmOutput> = dmListV2(token).dms;

  let channelGiven: channel;
  let dmGiven: dm;
  let messageGiven: message;
  const firstDigit = String(messageId)[0];
  if (firstDigit === '1') {
    // Checking if messageId is valid
    channelGiven = isMessageValidChannel(messageId);

    // Checking if user is global owner, otherwise check if member/owner of the message's channel
    if (user.isGlobalOwner === 2) {
      if (channelsMemberOf.find(channel => channel.channelId === channelGiven.channelId) === undefined) {
        throw HTTPError(BAD_REQ, 'Invalid access to message');
      } else if (channelGiven.ownerMembers.find(user => user === userId) === undefined) {
        throw HTTPError(FORBID, 'Invalid access to pinning message');
      }
    }

    messageGiven = channelGiven.messages.find(message => message.messageId === messageId);
  } else if (firstDigit === '2') {
    // Checking if messageId is valid
    dmGiven = isMessageValidDm(messageId);

    // Checking if member/owner of the message's channel
    if (dmsMemberOf.find(dm => dm.dmId === dmGiven.dmId) === undefined) {
      throw HTTPError(BAD_REQ, 'Invalid access to message');
    } else if (dmGiven.owner !== userId) {
      throw HTTPError(FORBID, 'Invalid access to pinning message');
    }

    messageGiven = dmGiven.messages.find(message => message.messageId === messageId);
  }

  if (mode === 'p' && messageGiven.isPinned === true) {
    throw HTTPError(BAD_REQ, 'Message already pinned');
  } else if (mode === 'u' && messageGiven.isPinned === false) {
    throw HTTPError(BAD_REQ, 'Message already unpinned');
  }

  let messageGivenIndex: number;
  if (firstDigit === '1') {
    const channelGivenIndex = data.channels.findIndex(channel => channel.channelId === channelGiven.channelId);
    messageGivenIndex = channelGiven.messages.findIndex(message => message.messageId === messageId);

    data.channels[channelGivenIndex].messages[messageGivenIndex].isPinned = !messageGiven.isPinned;
  } else if (firstDigit === '2') {
    const dmGivenIndex = data.dms.findIndex(dm => dm.dmId === dmGiven.dmId);
    messageGivenIndex = dmGiven.messages.findIndex(message => message.messageId === messageId);

    data.dms[dmGivenIndex].messages[messageGivenIndex].isPinned = !messageGiven.isPinned;
  }

  setData(data);
  return {};
}

/// Helper Functions ///

/**
 * Helper function for messageSend, messageSendDm and messageShare
 * Creates a new message, sends it to desired channel/dm and returns id.
 *
 * Arguments:
 *      message:            string     The message
 *      index:              number     The channel/dm's index in the dataStore
 *      membersOf:          object[]   An array of channels/dms user is member of
 *
 * Returns:
 *      sharedMessageId:    number     The message's unique identifier
 */
function sendMessage(mode: string, userId: number, message: string, index: number, ogMessage?: string) {
  const data: dataStoreType = getData();

  if (ogMessage !== undefined) {
    // Concat new message
    if (message.length > 0) {
      message = ogMessage.concat(' ', message);
    } else {
      message = ogMessage;
    }
  }

  let newMessageId: number;
  if (mode === 'c') {
    newMessageId = generateId(mode);
  } else if (mode === 'd') {
    newMessageId = generateId(mode);
  }

  const newMessage: message = {
    messageId: newMessageId,
    uId: userId,
    timeSent: Math.floor(Date.now() / 1000),
    message: message,
    isPinned: false,
  };

  if (mode === 'c') {
    data.channels[index].messages.unshift(newMessage);
  } else if (mode === 'd') {
    data.dms[index].messages.unshift(newMessage);
  }

  setData(data);

  return newMessageId;
}

/**
 * Helper function to check if messageId is valid and returns the channel
 * the message is in if valid
 *
 * Arguments:
 *      messageId:      number     The message's unique identifier
 *
 * Returns:
 *      channelGiven:   object     The message's corresponding channel
 */
function isMessageValidChannel(messageId: number) {
  const data: dataStoreType = getData();

  let channelGiven: channel;
  const isValid: boolean = data.channels.every((channel) => {
    // If messageId exists in channel returns false, else returns true
    if (channel.messages.find(message => message.messageId === messageId) !== undefined) {
      channelGiven = channel;
      return false;
    }

    return true;
  });

  if (isValid === true) {
    throw HTTPError(BAD_REQ, 'Invalid messageId');
  }

  return channelGiven;
}

/**
 * Helper function to check if messageId is valid and returns the DM
 * the message is in if valid
 *
 * Arguments:
 *      messageId:      number     The message's unique identifier
 *
 * Returns:
 *      dmGiven:        object     The message's corresponding DM
 */
function isMessageValidDm(messageId: number) {
  const data: dataStoreType = getData();

  let dmGiven: dm;
  const isValid: boolean = data.dms.every((dm) => {
    // If messageId exists in dm returns false, else returns true
    if (dm.messages.find(message => message.messageId === messageId) !== undefined) {
      dmGiven = dm;
      return false;
    }

    return true;
  });

  if (isValid === true) {
    throw HTTPError(BAD_REQ, 'Invalid messageId');
  }

  return dmGiven;
}
